\documentclass[10pt]{article}

\usepackage{amsmath}
\usepackage{textcomp}
\usepackage[top=20mm, bottom=16mm, left=22mm, right=18mm]{geometry}
% Add other packages here %
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{changepage}
\usepackage{float}
\usepackage[pdftex]{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[font=scriptsize]{subcaption}
\usepackage[font=scriptsize]{caption}

% Put your group number and names in the author field %
\title{\bf Excercise 4\\ Implementing a centralized agent}
\author{Group \textnumero 23: Jean-Thomas Furrer, Emily Hentgen}

% N.B.: The report should not be longer than 3 pages %


\begin{document}
\maketitle

\section{Solution Representation}

\subsection{Variables}
% Describe the variables used in your solution representation %
We use two variables for representing a plan resulting from the Stochastic Local Search (SLS) algorithm:
\begin{itemize}
\item[]Map\textless Vehicle, TaskAction\textgreater\ \textit{vehicleToFirstTaskAction}: maps a vehicle to the first task action it has to perform (necessarily a pick up, may be \texttt{null} if the vehicle picks up no task at all)
\item[]Map\textless TaskAction, TaskAction\textgreater\ \textit{taskActionToTaskAction}: maps a task action to the next task action performed by the same vehicle; used jointly with \textit{vehicleToFirstTaskAction} in order to know which vehicle handles which set of tasks
\end{itemize}

%unlike PDP where each vehicle carries one task at a time, cannot used only Task, because need to differentiate between pickup and delivery


\subsection{Constraints}
% Describe the constraints in your solution representation %
%todo: change X to effective (final) number of constraints
We (explicitly) enforce 2 constraints:
\begin{itemize}
\itemsep 0mm
\item[--] The load of each vehicle must not exceed its capacity.
\item[--] The delivery of a task cannot happen before the pickup of this same task.
\end{itemize}

Otherwise, constraints such as 'all tasks must be delivered' are enforced by the design of our SLS algorithm.

\subsection{Objective function}
% Describe the function that you optimize %
The objective function we optimize is the total travel cost resulting from all pickups and deliveries of all vehicles.

\section{Stochastic optimization}

\subsection{Initial solution}
% Describe how you generate the initial solution %
One possible initial solution consists of assigning all tasks to the vehicle with the largest capacity, in any order, if possible: if the weight of the heaviest task exceeds the capacity of the largest vehicle, then there is no solution to this pick up and delivery problem.
%This allows to check the problem is actually solvable: if the weight of the heaviest task exceeds the capacity of the largest vehicle, then there is no solution to this pick up and delivery problem.
In \textit{vehicleToFirstTaskAction}, we add an entry mapping the largest vehicle to a any task pickup, and map all the other vehicles to the \texttt{null} value.
In \textit{taskActionToTaskAction}, we begin by mapping the first task pickup to its corresponding task delivery. We then map this task delivery to any the pickup of any task in the set of remaining tasks, and map the latter task pickup to its corresponding task delivery, and so on.
Each time a task is selected, we remove it from the set of remaining tasks: the mapping \textit{taskActionToTaskAction} is complete once the set of remaining tasks is empty.

\subsection{Generating neighbours}
% Describe how you generate neighbors %
We use almost the same two transformations as in the Pickup and Delivery Problem where each vehicle is allowed to carry only one task at a time: a neighbour plan can be generated by either swapping the order of two tasks for the same vehicle, or by giving the first task of one vehicle to another.
We firstly generate a potential neighbour plan without enforcing the constraints. It is after it has been generated that we check whether the constraints are respected: if this is the case, we add it to the set of neighbouring plans, otherwise, we discard it.

\subsection{Stochastic optimization algorithm}
% Describe your stochastic optimization algorithm %
Our stochastic optimization algorithm will stop either because it reaches the timeout limit defined at the beginning of the simulation, or because there was no improvement in the cost of the plan for a certain number of iterations.
For selecting the next plan, it uses a local choice function which, depending on a certain probability distribution, returns a neighbouring minimal cost plan, the current plan, or a random plan (which can be a minimal cost plan). This is because systematically returning a minimal cost plan may lead the stochastic local search to get stuck in a local minimum. This also depends on the initial solution defined at the setup.

\begin{algorithm}[h]
\caption{Stochastic Local Search}
\begin{algorithmic}[0]
\Statex \textsc{Input}
\Statex \hspace{\algorithmicindent} List\textless Vehicle\textgreater\ \textit{vehicles} \Comment{a list of the agent's vehicles}
\Statex \hspace{\algorithmicindent} TaskSet \textit{tasks} \Comment{the set of tasks to deliver}
\Statex \textsc{Output}
\Statex \hspace{\algorithmicindent} Plan \textit{plan} \Comment{a (sub)optimal plan}

\State
\State $initialCountdown \gets 100\ 000$, $countdown \gets initialCountdown$ 
\State $hasTimedOut \gets False$, $noImprovement \gets False$
\State $minimumCostAchieved \gets  \infty$
\State $plan \gets  selectInitialSolution(tasks)$, $bestPlan \gets null$
\State
\While{((not $hasTimedOut$) and (not $noImprovement$))}
\State $previousPlan \gets plan$
\State $neighbourPlans \gets chooseNeighbours(previousPlan)$ \Comment{returns the neighbours of the current plan}
\State $plan \gets localChoice(neighbourPlans)$ \Comment{selects the next plan}
\State
\If{$(duration \geq timeout)$}  \Comment{in practice, subtract a margin to the \textit{timeout}}
	\State $timeOut \gets True$ \Comment{(e.g. 1s) so that the algorithm stops before it}
\EndIf                          \Comment{\textit{effectively} times out \hspace{38mm}}

\If{$(plan.cost >= minimumCostAchieved)$}
	\State $--countdown$
\Else
	\State $countdown \gets initialCountdown$
	\State $minimumCostAchieved \gets plan.cost$
	\State $bestPlan \gets plan$
\EndIf
\If{$(countdown = 0)$}
	\State $noImprovement \gets True$
\EndIf
\EndWhile
\State \Return $bestPlan$
\end{algorithmic}
\end{algorithm}

\section{Results}

\subsection{Experiment 1: Model parameters}
% if your model has parameters, perform an experiment and analyze the results for different parameter values %
Our SLS algorithm has three parameters: the probability that a minimum cost plan is selected, the probability that a random plan is selected, and the maximum number of iterations without improvement before the search stops.

\subsubsection{Setting}
% Describe the settings of your experiment: topology, task configuration, number of tasks, number of vehicles, etc. %
% and the parameters you are analyzing %
We mostly tested the performance of the SLS algorithm for different probability distributions. 
If the maximum number of iterations is "large enough", but not "too large", the SLS algorithm often manages to find a (sub)optimal plan before it actually times out (which happens after 303 000 ms). 
A value of 10 000 seems reasonable: the algorithm does not stop too early, and still manages too find a plan with a cost consistent throughout multiple simulations. 
For these simulations, we kept the initial seed of 12345.

\subsubsection{Observations}
% Describe the experimental results and the conclusions you inferred from these results %
We report the minimum observed cost, maximum observed cost and average cost of the suboptimal plans, as well as the average execution time, over roughly 6 simulations per configuration.\\

\begin{tabular}{|l|rrrr|rrrr|}
\hline
number of tasks & 20 & & & & 30 & & & \\
\hline
$p_{minimum\ cost\ plan}$ & 0.3 & 0.4 & 0.5 & 0.7 & 0.3 & 0.4 & 0.5 & 0.7\\
$p_{current\ plan}$       & 0.5 & 0.4 & 0.3 & 0.1 & 0.5 & 0.4 & 0.3 & 0.1\\
$p_{random\ plan}$        & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2\\
\hline
minimum cost observed &  9 347 &  9 347 &  9 347 &  9 347 & 13 484 & 12 876 & 12 451 & 11 559\\
maximum cost observed & 10 072 & 10 679 & 11 931 & 11 429 & 16 693 & 15 144 & 14 492 & 15 392\\
%minimum cost observed & 9 347 & 9347 & 9347 & 9 347 & & & & \\
%maximum cost observed & 10 925 & 10 066 & 10 924 & 11 662 & & & & \\
\hline
average cost                &  9 627 &  9 894 & 10 246 & 10 248 &  14 325 &  13 715 &  13 567 & 13 382\\
average execution time (ms) & 95 207 & 95 774 & 71 630 & 86 475 & 161 027 & 227 860 & 200 463 & 209 973\\
%average cost & 9960 & 9620 & 9661 & 10 096 & & & & \\
%average execution time (ms) & 32 248 & 37 951 & 32 836 & 38 154 & & & & \\
\hline
\end{tabular}
\captionof{table}{seed: 12345, countdown: 10 000, initial solution: assigns all tasks to the largest vehicle}
\label{table:model_parameters}
\vspace{4mm}
For a relatively large probability of picking a minimum cost plan, most of the time, the plan found repeatedly reaches a low cost, particularly for 20 tasks. Some plans however turn out to have a somewhat larger cost, which confirms our intuition about getting stuck in a local minimum. 
For 30 tasks, the execution time is significantly longer, and the different probability distributions to not systematically find the lowest cost plan. In fact, the SLS algorithm sometimes times out, which is most likely because the complexity of the problem is now much larger than before.

%On average though, setting this probability to a high value, so that the SLS algorithm converges faster, resulted in lower plan costs.
%What is interesting as well is that the cost of a plan does not significantly increase from 20 tasks to 30 tasks: the SLS algorithm manages to combine pickups and deliveries so that the cost of a suboptimal plan remains in the same range.

\subsection{Experiment 2: Different configurations}
% Run simulations for different configurations of the environment (i.e. different tasks and number of vehicles) %
We observed that for a large number of tasks (e.g. 20 or more), the SLS algorithm tends to assign all tasks to a single vehicle (the vehicle that initially gets all the tasks).
There may be two reasons for this. One may be that the number of neighbouring plans where the order of the tasks is changed is much larger than the number of neighbouring plans giving the first task of a vehicle to another one. 
The other may be that it is simply cheaper and easily feasible to have a unique vehicle doing all the work, since there are many tasks to deliver, and only few cities: a large enough vehicle capacity combined with tasks of small weights gives the vehicle a certain flexibility for the order in which tasks can be picked up and delivered - a flexibility which is not necessarily larger when there are more vehicles involved.
In this experiment, we want to compare the performance of the SLS algorithm for a different initial solution. 
\subsubsection{Setting}
% Describe the settings of your experiment: topology, task configuration, number of tasks, number of vehicles, etc. %
We kept the same setting as in Experiment 1, except for the initial solution: at the beginning, each vehicle now receives roughly the same number of tasks, as long as it can carry each one of them.

\subsubsection{Observations}
% Describe the experimental results and the conclusions you inferred from these results %
% Reflect on the fairness of the optimal plans. Observe that optimality requires some vehicles to do more work than others. %
% How does the complexity of your algorithm depend on the number of vehicles and various sizes of the task set? %

\begin{tabular}{|l|rrrr|rrrr|}
\hline
number of tasks & 20 & & & & 30 & & & \\
\hline
$p_{minimum\ cost\ plan}$ & 0.3 & 0.4 & 0.5 & 0.7 & 0.3 & 0.4 & 0.5 & 0.7\\
$p_{current\ plan}$       & 0.5 & 0.4 & 0.3 & 0.1 & 0.5 & 0.4 & 0.3 & 0.1\\
$p_{random\ plan}$        & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2 & 0.2\\
\hline
minimum cost observed & 10 480 &  9 889 & 13 042 &  9 347 & 12 543 & 13 004 & 13 486 & 18 036\\
maximum cost observed & 14 557 & 14 199 & 16 076 & 13 542 & 19 882 & 21 930 & 19 209 & 23 408\\
\hline
average cost                & 12 014 & 14 718 & 11 918 & 12 225 &  16 405 & 18 203 & 17 404 & 19 897\\
average execution time (ms) & 43 634 & 21 244 & 63 120 & 58 786 & 182 548 & 88 736 & 87 360 & 62 573\\
\hline
\end{tabular}
\captionof{table}{seed: 12345, countdown: 10 000, initial solution: assigns roughly an equal number of tasks to all vehicles}
\label{table:model_parameters_2}
\vspace{4mm}

With this different initial solution, the search stops sooner on average, and the resulting cost is higher. If we were to increase the countdown, this initial solution might eventually display lower plan costs though, closer to the costs of the plans found with the previous initial solution.
What is more, the SLS algorithm still tends to distribute all tasks between one vehicle, at most two, the others having not task assigned.
This suggests that a plan assigning all tasks to a single vehicle is for the company optimal, instead of one using all available vehicles and trying to be "fair" among them all.
If we added a time constraint in the simulation - the company's vehicle must deliver the tasks within a given amount of time, and are penalized if they do not - then the corresponding SLS algorithm would most likely tend to assign the tasks to multiple vehicles instead of only one.

\end{document}