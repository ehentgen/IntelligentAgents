\documentclass[10pt]{article}

\usepackage{amsmath}
\usepackage{textcomp}
\usepackage[top=20mm, bottom=18mm, left=24mm, right=20mm]{geometry}
% Add other packages here %
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{changepage}
\usepackage{float}
\usepackage[pdftex]{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[font=scriptsize]{subcaption}
\usepackage[font=scriptsize]{caption}

% Put your group number and names in the author field %
\title{\bf Excercise 4\\ Implementing a centralized agent}
\author{Group \textnumero 23: Jean-Thomas Furrer, Emily Hentgen}

% N.B.: The report should not be longer than 3 pages %


\begin{document}
\maketitle

\section{Solution Representation}

\subsection{Variables}
% Describe the variables used in your solution representation %
We use two variables for representing a plan resulting from the Stochastic Local Search (SLS) algorithm:
\begin{itemize}
\item[]Map\textless Vehicle, TaskAction\textgreater\ \textit{vehicleToFirstTaskAction}: maps a vehicle to the first task action it has to perform (necessarily a pick up, may be \texttt{null} if the vehicle picks up no task at all)
\item[]Map\textless TaskAction, TaskAction\textgreater\ \textit{taskActionToTaskAction}: maps a task action to the next task action performed by the same vehicle; used jointly with \textit{vehicleToFirstTaskAction} in order to know which vehicle handles which set of tasks
\end{itemize}

%unlike PDP where each vehicle carries one task at a time, cannot used only Task, because need to differentiate between pickup and delivery


\subsection{Constraints}
% Describe the constraints in your solution representation %
%todo: change X to effective (final) number of constraints
We (explicitly) enforce 2 constraints:
\begin{itemize}
\itemsep 0mm
\item[--] The load of each vehicle must not exceed its capacity.
\item[--] The delivery of a task cannot happen before the pickup of this same task.
\end{itemize}

Otherwise, constraints such that 'all tasks must be delivered' are enforced by the design of our SLS algorithm.

\subsection{Objective function}
% Describe the function that you optimize %
The objective function we optimize is the total travel cost resulting from all pickups and deliveries of all vehicles.

\section{Stochastic optimization}

\subsection{Initial solution}
% Describe how you generate the initial solution %
One possible initial solution consists of assigning all tasks to the vehicle with the largest capacity, in any order, if possible: if the weight of the heaviest task exceeds the capacity of the largest vehicle, then there is no solution to this pick up and delivery problem.
%This allows to check the problem is actually solvable: if the weight of the heaviest task exceeds the capacity of the largest vehicle, then there is no solution to this pick up and delivery problem.
In \textit{vehicleToFirstTaskAction}, we add an entry mapping the largest vehicle to a any task pickup, and map all the other vehicles to the \texttt{null} value.
In \textit{taskActionToTaskAction}, we begin by mapping the first task pickup to its corresponding task delivery. We then map this task delivery to any the pickup of any task in the set of remaining tasks, and map the latter task pickup to its corresponding task delivery, and so on.
Each time a task is selected, we remove it from the set of remaining tasks: the mapping \textit{taskActionToTaskAction} is complete once the set of remaining tasks is empty.

\subsection{Generating neighbours}
% Describe how you generate neighbors %
We use almost the same two transformations as in the Pickup and Delivery Problem where each vehicle is allowed to carry only one task at a time: a neighbour plan can be generated by either swapping the order of two tasks for the same vehicle, or by giving the first task of one vehicle to another.
We firstly generate a potential neighbour plan without enforcing the constraints. It is after it has been generated that we check whether the constraints are respected: if this is the case, we add it to the set of neighbouring plans, otherwise, we discard it.

\subsection{Stochastic optimization algorithm}
% Describe your stochastic optimization algorithm %

Our stochastic optimization algorithm will stop either because it reaches the timeout limit defined at the beginning of the simulation, or because there was no improvement in the cost of the plan for a certain number of iterations.
For selecting the next plan, it uses a local choice function which, depending on a certain probability distribution, returns a neighbouring minimal cost plan, the current plan, or a random plan (which can be a minimal cost plan). This is because systematically returning a minimal cost plan may lead the stochastic local search to get stuck in a local minimum. This also depends on the initial solution defined at the setup.

\begin{algorithm}[h]
\caption{Stochastic Local Search}
\begin{algorithmic}[0]
\Statex \textsc{Input}
\Statex \hspace{\algorithmicindent} List\textless Vehicle\textgreater\ \textit{vehicles} \Comment{a list of the agent's vehicles}
\Statex \hspace{\algorithmicindent} TaskSet \textit{tasks} \Comment{the set of tasks to deliver}
\Statex \textsc{Output}
\Statex \hspace{\algorithmicindent} Plan \textit{plan} \Comment{a (sub)optimal plan}

\State	
\State $initialCountdown \gets 100 000$, $countdown \gets initialCountdown$
\State $hasTimedOut \gets False$, $noImprovement \gets False$
\State $minimumCostAchieved \gets  \infty$
\State $plan \gets  selectInitialSolution(tasks)$
\State
\While{((not $hasTimedOut$) and (not $noImprovement$))}
\State $previousPlan \gets plan$
\State $neighbourPlans \gets chooseNeighbours(previousPlan)$
\State $plan \gets localChoice(neighbourPlans)$
\State
\If{$(duration > timeout)$} 
	\State $timeOut \gets True$
\EndIf

\If{$(plan.cost >= minimumCostAchieved)$}
	\State $--countdown$
\Else
	\State $countdown \gets initialCountdown$
	\State $minimumCostAchieved \gets plan.cost$
\EndIf
\If{$(countdown = 0)$}
	\State $noImprovement \gets True$
\EndIf
\EndWhile
\State \Return $plan$
\end{algorithmic}
\end{algorithm}

\section{Results}

\subsection{Experiment 1: Model parameters}
% if your model has parameters, perform an experiment and analyze the results for different parameter values %
Our SLS algorithm has three parameters: the probability that a minimum cost plan is selected, the probability that a random plan is selected, and the maximum number of iterations without improvement before the search stops.

\subsubsection{Setting}
% Describe the settings of your experiment: topology, task configuration, number of tasks, number of vehicles, etc. %
% and the parameters you are analyzing %
We mostly tested the performance of the SLS algorithm for different probability distributions: as long as the number of iterations without improvement is "large enough", its influence on the cost of the plan is going to be limited. We observed that for low values such as 10 000, the SLS algorithm tends to stop because there is no more improvement. Therefore, we set this value to 100 000, such that the algorithm times out for most simulations (when 303 000 ms is reached): this way, we are guaranteed the search did not stop "too soon".
For these simulations, we kept the initial seed of 12345.

\subsubsection{Observations}
% Describe the experimental results and the conclusions you inferred from these results %
We report the minimum observed cost and maximum observed cost of the suboptimal plans, over roughly 6 simulations per configuration, with a maximum number of iterations without improvement of 100 000.\\

\begin{tabular}{|l|llll|llll|}
\hline
number of tasks & 20 & & & & 30 & & & \\
\hline
$p_{minimum\ cost\ plan}$ & 0.3 & 0.4 & 0.5 & 0.8 & 0.3 & 0.4 & 0.5 & 0.8\\
$p_{random\ plan}$        & 0.6 & 0.3 & 0.2 & 0.1 & 0.6 & 0.3 & 0.2 & 0.1\\
$p_{current\ plan}$       & 0.1 & 0.3 & 0.3 & 0.1 & 0.1 & 0.3 & 0.3 & 0.1\\
\hline
minimum cost observed & 9 347 &  10 249 & 10 321 & 9 347  &  15 226 & 14 236 & 14 946 & 13 062 \\
%execution time (ms)   & 302 009 & 142 337 & 302 010 & 302 067 & 302 017 & 302 013 & 302 013 & 263 720\\ 
%\hline
maximum cost observed & 14 201 & 20 811 & 22 513 & 15 593  &  30 582 & 37 728 & 23 646 & 22 122\\
%execution time (ms)   & 302 022 & 302 010 & 71 191 & 53 445  & 246 548 & 249 670 & 302 011 & 203 105\\
\hline
average cost observed & 11 348 & 15 897 & 14 912 & 11 390 & 19 513 & 19 167 & 17 797 & 15 971 \\
\hline
\end{tabular}
\captionof{table}{seed: 12345, countdown: 100 000, initial solution: assigns all tasks to the largest vehicle}
\label{table:model_parameters}
\vspace{4mm}

%15226 + 30582 + 16305 + 21311 + 16585 + 17073
%15944 + 37728 + 14276 + 18310 + 14512 + 14236
%16282 + 19584 + 23646 + 14946 + 17331 + 14993
%13062 + 22122 + 14097 + 15822 + 15837 + 14890

%11321 + 9347 + 14201 + 11429 + 10321 + 11470
%10249 + 18839 + 13278 + 18273 + 20811 + 14075 + 15754
%11157 + 22513 + 14537 + 18749 + 12744 + 14366 + 10321
%9943 + 15593 + 9653 + 13699 + 9347 + 9653 + 11842

%For all the different steps, we observed that for a larger execution time, the plan cost was not necessarily lower.
%What is more, a plan having a similar cost to another could at the same time have been found in twice as much time.

For a relatively large probability of picking a minimum cost plan, even though most of the time, the plan found has a rather low cost, some of the other plans turned out to have a quite large cost, which confirms our intuition about the likeliness of getting stuck in a local minimum. 
In average though, setting this probability to a high value, so that the SLS algorithm converges faster, resulted in lower plan costs.

What is interesting as well is that the cost of a plan does not significantly increase from 20 tasks to 30 tasks: the SLS algorithm manages to combine pickups and deliveries so that the cost of a suboptimal plan remains in the same range.

%The time it takes to find a plan is significantly longer though: 
%When the company has to deliver 30 tasks, for most simulations, the search of the plan does not stop because there is no improvement after a given number of iterations, but actually times out (when 303 000 ms is reached).

\subsection{Experiment 2: Different configurations}
% Run simulations for different configurations of the environment (i.e. different tasks and number of vehicles) %
We observed that for a large number of tasks, the SLS algorithm tends to assign all tasks, or nearly all tasks, to a single vehicle (the vehicle that initially gets all the tasks), and just one or two to a second vehicle.
This may be because the number of neighbouring plans where the order of the tasks is changed is much larger than the number of neighbouring plans giving the first task of a vehicle to another one. 
In this experiment, we want to compare the performance of the SLS algorithm for a different initial solution. 
\subsubsection{Setting}
% Describe the settings of your experiment: topology, task configuration, number of tasks, number of vehicles, etc. %
We kept the same setting as in Experiment 1, only the initial solution has changed: at the beginning, each vehicle now receives roughly the same number of tasks, as long as it can carry each one of them.

\subsubsection{Observations}
% Describe the experimental results and the conclusions you inferred from these results %
% Reflect on the fairness of the optimal plans. Observe that optimality requires some vehicles to do more work than others. %
% How does the complexity of your algorithm depend on the number of vehicles and various sizes of the task set? %

\begin{tabular}{|l|llll|llll|}
\hline
number of tasks & 20 & & & & 30 & & & \\
\hline
$p_{minimum\ cost\ plan}$ & 0.3 & 0.4 & 0.5 & 0.8 & 0.3 & 0.4 & 0.5 & 0.8\\
$p_{random\ plan}$        & 0.6 & 0.3 & 0.2 & 0.1 & 0.6 & 0.3 & 0.2 & 0.1\\
$p_{current\ plan}$       & 0.1 & 0.3 & 0.3 & 0.1 & 0.1 & 0.3 & 0.3 & 0.1\\
\hline
minimum cost observed & 9 888  & 12 871 & 9 347 & 9 865 & 18 041  & 16 375 & 15 939 & 16 914 \\
%execution time (ms)   & 302 009 & 302 010 & 302 010 & 302 009 & 302 010 & 302 023 & 302 029 & 302 010\\ 
%\hline
maximum cost observed & 16 696 & 21 048 & 24 352 & 19 072 & 26 311 & 38 715 & 26 591 & 25 360\\
%execution time (ms)   & 302 008 & 302 009 & 302 008 & 192 579 & 302 007 & 302 016 & 302 023 & 302 013\\
\hline
average cost observed & 13 464 & 16 112 & 13 867 & 14 599 & 22 778 & 25 610 & 20 733 & 22 469\\
\hline
\end{tabular}
\captionof{table}{seed: 12345, countdown: 100 000, initial solution: assigns roughly an equal number of tasks to all vehicles}
\label{table:model_parameters_2}
\vspace{4mm}

With this different initial solution, the SLS algorithm still tends to distribute all tasks between one or two vehicles.
And it turned out that among all these suboptimal plans, the best ones often had only a single vehicle.

If we added a time constraint in the simulation - the company's vehicle must deliver the tasks within a given amount of time, and are penalized in they do not - then the corresponding SLS algorithm would most likely tend to assign the tasks to multiple vehicles.

\end{document}